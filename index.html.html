<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Goku Evolution - Proporción Perfecta</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Arial Black', sans-serif; }
        canvas { border: 4px solid #ffcc00; background: #000; cursor: pointer; box-shadow: 0 0 40px rgba(255, 204, 0, 0.6); }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 400; canvas.height = 600;

// --- CONFIGURACIÓN CENTRAL ---
// Define aquí el ancho que tendrán tus columnas en el juego.
// La altura se calculará sola para NO deformar la imagen de 500x1000.
const PILAR_ANCHO_JUEGO = 85; 

const FORMS = {
    BASE:      { min: 0,  label: "GOKU NORMAL",    color: "#fff",    sky: "#1a75ff", img: "GOKU NORMAL.png", aura: false, shakeImpact: 0,  shakeSteady: 0,   speed: 3.5, gap: 210 },
    BASE_M:    { min: 5,  label: "GOKU MEJORADO",  color: "#ddd",    sky: "#1565c0", img: "GOKU MEJORADO.png", aura: false, shakeImpact: 10, shakeSteady: 0.9, speed: 3.8, gap: 200 },
    SSJ:       { min: 10, label: "GOKU SSJ 1",     color: "#FFD700", sky: "#ff9900", img: "GOKU SSJ 1.png", aura: true,  shakeImpact: 20, shakeSteady: 2.0, speed: 4.2, gap: 195 },
    SSJ2:      { min: 15, label: "GOKU SSJ 2",     color: "#FFEE00", sky: "#e68a00", img: "GOKU SSJ 2.png", aura: true,  shakeImpact: 30, shakeSteady: 3.0, speed: 4.6, gap: 190 },
    SSJ3:      { min: 20, label: "GOKU SSJ 3",     color: "#FFD700", sky: "#cc7a00", img: "GOKU SSJ 3.png", aura: true,  shakeImpact: 45, shakeSteady: 4.0, speed: 5.0, gap: 185 },
    SSJ_ROJO:  { min: 25, label: "GOKU ROJO",      color: "#FF4500", sky: "#801a1a", img: "GOKU ROJO.png", aura: true,  shakeImpact: 60, shakeSteady: 5.2, speed: 5.4, gap: 180 },
    SSJ_AZUL:  { min: 30, label: "GOKU AZUL",      color: "#00BFFF", sky: "#0d47a1", img: "GOKU AZUL.png", aura: true,  shakeImpact: 75, shakeSteady: 6.2, speed: 5.8, gap: 175 },
    ULTRA:     { min: 35, label: "ULTRA INSTINTO", color: "#E0E0E0", sky: "#2c1a4d", img: "ULTRA INSTINTO.png", aura: true, shakeImpact: 90, shakeSteady: 7.5, speed: 6.3, gap: 168 }
};

const sprites = {};
Object.keys(FORMS).forEach(k => { sprites[k] = new Image(); sprites[k].src = FORMS[k].img; });
// Asegúrate de que tu imagen se llame exactamente así y esté en la misma carpeta
const colImg = new Image(); colImg.src = "columnas.png"; 

let score = 0, gameState = "START", currentKey = "BASE", frameCount = 0;
let pipes = [], clouds = [], stars = [], warpLines = [], particles = [], shake = 0, flash = 0;
let highScore = localStorage.getItem("gokuHighScore") || 0;

const goku = { x: 60, y: 300, w: 60, h: 85, v: 0, gravity: 0.25, jump: -5.3 };

function reset() {
    score = 0; pipes = []; clouds = []; warpLines = []; particles = []; frameCount = 0;
    goku.y = 300; goku.v = 0; currentKey = "BASE";
    gameState = "PLAYING"; shake = 0; flash = 0;
    stars = Array.from({length: 45}, () => ({ x: Math.random()*400, y: Math.random()*600, s: Math.random()*2+1 }));
    for(let i=0; i<6; i++) clouds.push({ x: Math.random()*400, y: Math.random()*150, w: 100, s: 0.4 + Math.random()*0.4 });
}

function update() {
    if (gameState !== "PLAYING") return;
    frameCount++;
    goku.v += goku.gravity; goku.y += goku.v;

    let nextKey = "BASE";
    Object.keys(FORMS).forEach(k => { if (score >= FORMS[k].min) nextKey = k; });

    if (nextKey !== currentKey) {
        currentKey = nextKey;
        shake = FORMS[currentKey].shakeImpact; flash = 10;
    }
    if (flash > 0) flash--;

    if (FORMS[currentKey].aura && Math.random() > 0.6) {
        particles.push({ x: goku.x + Math.random()*goku.w, y: goku.y + goku.h, s: 1 + Math.random()*3, o: 1 });
    }
    particles.forEach((p, i) => { p.y -= p.s; p.o -= 0.02; if(p.o <= 0) particles.splice(i, 1); });

    if (score >= 20 && Math.random() > 0.65) {
        warpLines.push({ x: 400, y: Math.random()*600, len: 50+Math.random()*70, s: 20+Math.random()*12 });
    }
    warpLines.forEach((l, i) => { l.x -= l.s; if (l.x + l.len < 0) warpLines.splice(i, 1); });

    if (frameCount % 92 === 0) {
        let gap = FORMS[currentKey].gap;
        let top = Math.random() * (canvas.height - gap - 240) + 120;
        pipes.push({ x: canvas.width, t: top, g: gap, p: false });
    }

    pipes.forEach((p, i) => {
        p.x -= (FORMS[currentKey].speed + score * 0.025);
        
        // --- HITBOX (COLISIÓN) ---
        // Usamos PILAR_ANCHO_JUEGO para que la colisión sea exacta al dibujo.
        // Ajustamos los márgenes (+22, -22) para ser un poco permisivos con los bordes de Goku.
        if (goku.x + 22 < p.x + PILAR_ANCHO_JUEGO && 
            goku.x + goku.w - 22 > p.x && 
           (goku.y + 22 < p.t || goku.y + goku.h - 22 > p.t + p.g)) {
            endGame();
        }
        
        if (!p.p && p.x + PILAR_ANCHO_JUEGO < goku.x) { score++; p.p = true; }
        if (p.x < -200) pipes.splice(i, 1);
    });

    stars.forEach(s => { s.x -= 0.6; if(s.x < 0) s.x = 400; });
    clouds.forEach(c => { c.x -= c.s; if(c.x + c.w < -60) c.x = 460; });
    if (goku.y > canvas.height || goku.y < 0) endGame();
}

function endGame() {
    gameState = "GAMEOVER";
    if ((score * 10) > highScore) { highScore = score * 10; localStorage.setItem("gokuHighScore", highScore); }
}

function draw() {
    update();
    ctx.clearRect(0,0, canvas.width, canvas.height);
    ctx.save();

    if (shake > 0 || FORMS[currentKey].shakeSteady > 0) {
        ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
        let steady = FORMS[currentKey].shakeSteady;
        if (shake > steady) shake *= 0.94; else shake = steady;
    }

    let cfg = FORMS[currentKey] || FORMS.BASE;
    let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, cfg.sky); grad.addColorStop(1, "#000");
    ctx.fillStyle = grad; ctx.fillRect(-100, -100, canvas.width + 200, canvas.height + 200);

    ctx.fillStyle = "white"; stars.forEach(s => ctx.fillRect(s.x, s.y, 2, 2));
    ctx.fillStyle = "rgba(255,255,255,0.25)";
    clouds.forEach(c => { ctx.beginPath(); ctx.ellipse(c.x, c.y, c.w/2, 13, 0, 0, Math.PI*2); ctx.fill(); });

    warpLines.forEach(l => {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.beginPath();
        ctx.moveTo(l.x, l.y); ctx.lineTo(l.x + l.len, l.y); ctx.stroke();
    });

   // --- RENDERIZADO MODULAR (ESTILO FLAPPY BIRD PROFESIONAL) ---
pipes.forEach(p => {
    if (colImg.complete && colImg.naturalWidth > 0) {
        // 1. Definimos el ancho "robusto" de la columna
        const ANCHO_COL = 80; 
        
        // 2. Calculamos la altura de la imagen para que NO se deforme (Proporción 1:2)
        // Como tu imagen es 500x1000, si el ancho es 80, el alto DEBE ser 160.
        const ALTO_IMG = 160; 

        // --- COLUMNA SUPERIOR ---
        // Dibujamos el "cuerpo" (rectángulo de piedra)
        ctx.fillStyle = "#4a4a4a"; // Color gris piedra (ajústalo al tono de tu columna)
        ctx.fillRect(p.x, 0, ANCHO_COL, p.t - ALTO_IMG);
        
        // Dibujamos el detalle del dragón (invertido) justo en el borde del hueco
        ctx.save();
        ctx.translate(p.x + ANCHO_COL / 2, p.t); 
        ctx.scale(1, -1);
        ctx.drawImage(colImg, -ANCHO_COL / 2, 0, ANCHO_COL, ALTO_IMG); 
        ctx.restore();

        // --- COLUMNA INFERIOR ---
        // Dibujamos el detalle del dragón justo al empezar el hueco
        ctx.drawImage(colImg, p.x, p.t + p.g, ANCHO_COL, ALTO_IMG);
        
        // Dibujamos el "cuerpo" que falta hasta el suelo
        ctx.fillRect(p.x, p.t + p.g + ALTO_IMG, ANCHO_COL, canvas.height);

        // Borde fino para dar profundidad (opcional)
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x, 0, ANCHO_COL, p.t);
        ctx.strokeRect(p.x, p.t + p.g, ANCHO_COL, canvas.height);
    }
});

    if (cfg.aura) {
        ctx.save(); ctx.shadowBlur = 45; ctx.shadowColor = cfg.color;
        ctx.globalAlpha = 0.38; ctx.fillStyle = cfg.color;
        ctx.beginPath(); ctx.ellipse(goku.x + goku.w/2, goku.y + goku.h/2, goku.w/2+10, goku.h/2+10, 0, 0, Math.PI*2);
        ctx.fill(); ctx.restore();

        ctx.save(); ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.shadowBlur = 12; ctx.shadowColor = cfg.color;
        for (let i = 0; i < (currentKey === "ULTRA" ? 6 : 3); i++) {
            ctx.beginPath(); let sx = goku.x + Math.random()*goku.w, sy = goku.y + Math.random()*goku.h;
            ctx.moveTo(sx, sy); for (let j = 0; j < 3; j++) {
                ctx.lineTo(sx + (Math.random()-0.5)*40, sy + (Math.random()-0.5)*40);
                sx += (Math.random()-0.5)*18; sy += (Math.random()-0.5)*18;
            }
            ctx.stroke();
        } ctx.restore();
        
        particles.forEach(p => {
            ctx.fillStyle = `rgba(255, 255, 255, ${p.o})`;
            ctx.fillRect(p.x, p.y, 3, 3);
        });
    }

    let imgG = sprites[currentKey];
    if (imgG && imgG.complete) {
        let gRatio = imgG.naturalWidth / imgG.naturalHeight;
        goku.w = 85 * gRatio;
        ctx.drawImage(imgG, goku.x, goku.y, goku.w, 85);
    }
    
    ctx.restore();

    if (flash > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${flash/10})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // UI
    ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,canvas.width, 60);
    ctx.fillStyle = "#fff"; ctx.font = "bold 13px Arial"; ctx.textAlign = "left";
    ctx.fillText("KI ACTUAL: " + (score * 10), 15, 22);
    ctx.fillStyle = "#ffcc00"; ctx.fillText("RÉCORD: " + highScore, 15, 45);
    ctx.textAlign = "right"; ctx.fillStyle = cfg.color; ctx.font = "bold 18px Arial";
    ctx.fillText(cfg.label, 385, 35);

    if (gameState !== "PLAYING") {
        ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = "#ffcc00"; ctx.font = "bold 34px Arial"; ctx.textAlign = "center";
        ctx.fillText(gameState === "START" ? "GOKU EVOLUTION" : "GAME OVER", 200, 260);
        ctx.fillStyle = "#fff"; ctx.font = "19px Arial";
        ctx.fillText("KI MÁXIMO: " + highScore, 200, 310);
        ctx.font = "16px Arial"; ctx.fillText("HAZ CLIC O ESPACIO PARA VOLAR", 200, 360);
    }
    requestAnimationFrame(draw);
}

const action = (e) => {
    if (e.type === "keydown" && e.code !== "Space") return;
    if (e.code === "Space") e.preventDefault();
    if (gameState !== "PLAYING") reset(); else goku.v = goku.jump;
};
window.addEventListener("keydown", action);
canvas.addEventListener("mousedown", action);
draw();
</script>
</body>
</html>